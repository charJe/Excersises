(defconstant start-state '(3 3 0 0 "L"))

(defconstant goal-state '(0 0 3 3 "R"))

(defun goal-state-p (state &optional (goal goal-state) (goal-p t))
  (if (null state)
      goal-p
      (goal-state-p (cdr state)
                    (cdr goal)
                    (and goal-p
                         (equalp (car goal)
                                 (car state))))))

(defun successors (state)
  (remove nil
          (if (equalp (car (last state)) "L")
              (let* ((new-state (append (reverse (cdr (reverse state))) '("R")))
                     (m  (alter '(0 -1 0 1) new-state))
                     (mm (alter '(0 -2 0 2) new-state))
                     (c  (alter '(-1 0 1 0) new-state))
                     (cc (alter '(-2 0 2 0) new-state))
                     (cm (alter '(-1 -1 1 1) new-state)))
                (list (when (valid-state-p m) m)
                      (when (valid-state-p mm) mm)
                      (when (valid-state-p c) c)
                      (when (valid-state-p cc) cc)
                      (when (valid-state-p cm) cm)))
              (let* ((new-state (append (reverse (cdr (reverse state))) '("L")))
                     (m  (alter '(0 1 0 -1) new-state))
                     (mm (alter '(0 2 0 -2) new-state))
                     (c  (alter '(1 0 -1 0) new-state))
                     (cc (alter '(2 0 -2 0) new-state))
                     (cm (alter '(1 1 -1 -1) new-state)))
                (list (when (valid-state-p m) m)
                      (when (valid-state-p mm) mm)
                      (when (valid-state-p c) c)
                      (when (valid-state-p cc) cc)
                      (when (valid-state-p cm) cm))))))

(defun valid-state-p (state)
  (and (>= (nth 0 state) 0)
       (>= (nth 1 state) 0)
       (>= (nth 2 state) 0)
       (>= (nth 3 state) 0)
       (or (<= (nth 0 state)
              (nth 1 state))
           (= (nth 1 state) 0))
       (or (<= (nth 2 state)
              (nth 3 state))
           (= (nth 3 state) 0))))

(defun equal-state-p (a b &optional (same t))
  (if (null a)
      same
      (equal-state-p (cdr a)
                     (cdr b)
                     (and same
                          (equalp (car a)
                                  (car b))))))

(defun alter (alterations lst &optional (altered '()))
  (if (null alterations)
      (append altered lst)
      (alter (cdr alterations)
             (cdr lst)
             (append altered (list (+ (car lst) (car alterations)))))))

(defun dfs (&optional
              (stack `(,start-state))
              (visited '())
              (path '()))
  (cond
    ((null stack) nil)
    ((goal-state-p (car stack)) (append path (list (car stack))))
    (t (dfs (append (remove-if #'(lambda (s)
                                   (or (remove-if-not #'(lambda (s2)
                                                          (equal-state-p s s2))
                                                      visited)
                                       (remove-if-not #'(lambda (s2)
                                                          (equal-state-p s s2))
                                                      stack)))
                               (successors (car stack)))
                    (cdr stack))
            (union (list (car stack)) visited)
            (append path (list (car stack)))))))

